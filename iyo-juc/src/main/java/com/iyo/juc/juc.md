## JUC并发编程

### Future和CompletableFuture

![Future和Completablefuture的继承关系](../../../../resources/images/FutureTask.png)

### synchronized关键字

synchronized 用于实现线程同步，确保在多线程环境下，对共享资源的访问是线程安全的。它提供了互斥（mutual exclusion）和可见性（visibility）保证，以避免数据竞争、死锁、竞态条件等问题。以下是 synchronized 关键字的主要使用方式和特性：

1. **修饰实例方法:** 当 synchronized 修饰一个非静态实例方法时，它相当于对该方法所在的对象实例（即 this）加锁。在同一时刻，最多只有一个线程能够执行该方法。其他试图访问该方法的线程会被阻塞，直到持有锁的线程退出该方法，释放锁。
2. **修饰静态方法:** 当 synchronized 修饰一个静态方法时，它对整个类（即 Class 对象）加锁，而非特定的对象实例。因此，在同一时刻，最多只有一个线程能够执行该类的所有 synchronized 静态方法。
3. **修饰代码块:** synchronized 也可以修饰一个代码块，指定一个显式的锁对象。只有持有该锁对象的线程才能执行该代码块。
4. **内存可见性:** synchronized 不仅提供互斥，还确保了对共享变量的内存可见性。当一个线程退出 synchronized 代码块或方法时，它会将所有在该同步块中对变量的修改刷新到主内存中。当另一个线程进入对应的 synchronized 代码块或方法时，它会从主内存中获取最新的变量值
5. **重入性:** synchronized 锁是可重入的。这意味着一个线程在已经持有某个锁的情况下，可以再次进入由同一锁保护的 synchronized 代码块或方法，而不会被阻塞。这允许在嵌套或递归调用时保持锁的正确性

![1713043235206](../../../../resources/images/synchronized.png)



### volatile关键字

volatile 用于修饰变量，以确保对变量的访问遵循一定的内存语义，特别是针对多线程环境中的共享变量。使用 volatile 关键字有以下几个关键特性：

1. **可见性:**
   当一个变量被声明为 volatile 后，对它的写操作会立即刷新到主内存中。同样，对 volatile 变量的读操作总是从主内存中获取最新值，而不是从本地线程缓存（如 CPU 缓存）中读取。这意味着对 volatile 变量的修改对其他线程来说是立即可见的，消除了由于缓存一致性问题导致的数据不一致现象。
2. **禁止指令重排序:**
   volatile 关键字还提供了某种程度的内存屏障效果，阻止编译器和处理器对涉及 volatile 变量的指令进行重排序。这确保了对 volatile 变量的操作与其他内存操作之间的顺序关系，防止因重排序而导致的并发问题。例如，如果一个线程先写入 volatile 变量，然后进行其他操作，另一个线程则可以确保在读取该 volatile 变量时，能看到前一线程的所有相关操作都已完成。
3. **非原子性:**
   虽然 volatile 提供了上述内存可见性和有序性保证，但它 不保证原子性。对于复合操作（如递增、递减、非同步的赋值等），即使使用 volatile 修饰，也仍然可能存在多线程下的数据竞争。对于需要原子性操作的场景，应使用 synchronized、`java.util.concurrent.atomic` 包中的原子类（如 `AtomicInteger`、`AtomicLong` 等）或 Lock 接口及其实现。
4. 适用场景:
   volatile 适用于以下情况：
   单个变量的读写操作简单（如状态标志的设置与检查）且不需要原子性保证。
   多线程之间通过共享变量进行通信，且只需要确保变量的最新值对所有线程可见。
   需要禁止指令重排序以维持特定的执行顺序。

**示例代码：** 

```java
public class VolatileExample {
    private volatile boolean ready;

    public void setReady() {
        ready = true; // 写操作立即刷新到主内存
    }

    public void doTask() {
        while (!ready) { // 读操作总是从主内存获取最新值
            Thread.yield(); // 或者进行其他适当等待策略
        }
        // 当进入此行时，可以确保 `ready` 已经被设置为 `true`
        performActualTask();
    }

    private void performActualTask() {
        // ...
    }
}

```

#### 注意：

当使用一个**未被 volatile 修饰的布尔类型变量**作为中断标志来控制线程时，可能会遇到以下问题：

1. 可见性问题:
   未被 volatile 修饰的布尔变量在多线程环境下的写操作（如将其设为 true 以请求中断线程）可能不会立即传播到主内存，而是保留在写线程的本地缓存中。当目标线程尝试读取这个变量以检查中断请求时，它可能从其自己的缓存中获取过期的值，从而未能感知到中断请求。这会导致线程无法及时响应中断，继续执行不必要的工作或陷入无限等待。

2. 指令重排序:
   编译器和处理器为了优化性能，可能会对涉及未被 volatile 修饰的布尔变量的指令进行重排序。这可能导致线程观察到的变量值与实际发生的事件顺序不符，进一步影响中断判断的准确性。例如，线程可能先看到中断标志被清除，而后看到引起中断的条件发生，从而错过中断信号。
3. 缺乏原子性:
   即使没有 volatile，简单的布尔变量读写通常是原子的。但是，如果中断检查逻辑涉及到更复杂的操作（如检查变量后再做其他事情），那么整体操作就不再原子，可能在检查和响应之间被其他线程中断，造成中断逻辑的混乱。



